"""Parse markdown output from sdd render back into structured sections.

This module provides functionality to parse the markdown output generated by
SpecRenderer back into structured data that can be enhanced with AI insights.
"""

import re
from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any


@dataclass
class ParsedTask:
    """Represents a parsed task or subtask."""

    id: Optional[str] = None
    title: str = ""
    status: str = "pending"
    level: int = 4  # Heading level (4=task, 5=subtask, etc.)
    file_path: Optional[str] = None
    estimated_hours: Optional[float] = None
    changes: Optional[str] = None
    reasoning: Optional[str] = None
    details: Optional[str] = None
    depends_on: List[str] = field(default_factory=list)
    blocked_by: List[str] = field(default_factory=list)
    subtasks: List['ParsedTask'] = field(default_factory=list)
    raw_markdown: str = ""


@dataclass
class ParsedVerification:
    """Represents a parsed verification step."""

    title: str = ""
    status: str = "pending"
    verification_type: str = "manual"
    command: Optional[str] = None
    expected: Optional[str] = None
    raw_markdown: str = ""


@dataclass
class ParsedGroup:
    """Represents a task group (file modifications, verification, etc.)."""

    title: str = ""
    completed_tasks: int = 0
    total_tasks: int = 0
    blocked_by: List[str] = field(default_factory=list)
    tasks: List[ParsedTask] = field(default_factory=list)
    verifications: List[ParsedVerification] = field(default_factory=list)
    raw_markdown: str = ""


@dataclass
class ParsedPhase:
    """Represents a parsed phase."""

    title: str = ""
    completed_tasks: int = 0
    total_tasks: int = 0
    progress_pct: float = 0.0
    purpose: Optional[str] = None
    risk_level: Optional[str] = None
    estimated_hours: Optional[float] = None
    blocked_by: List[str] = field(default_factory=list)
    depends_on: List[str] = field(default_factory=list)
    groups: List[ParsedGroup] = field(default_factory=list)
    raw_markdown: str = ""


@dataclass
class ParsedSpec:
    """Represents a completely parsed specification."""

    title: str = ""
    spec_id: str = ""
    status: str = "pending"
    completed_tasks: int = 0
    total_tasks: int = 0
    progress_pct: float = 0.0
    estimated_hours: Optional[float] = None
    complexity: Optional[str] = None
    description: Optional[str] = None
    objectives: List[str] = field(default_factory=list)
    phases: List[ParsedPhase] = field(default_factory=list)
    raw_markdown: str = ""


class MarkdownParser:
    """Parse markdown output from SpecRenderer into structured sections."""

    def __init__(self, markdown: str):
        """Initialize parser with markdown content.

        Args:
            markdown: Complete markdown output from SpecRenderer
        """
        self.markdown = markdown
        self.lines = markdown.split('\n')

    def parse(self) -> ParsedSpec:
        """Parse complete markdown into structured spec.

        Returns:
            ParsedSpec with all sections parsed
        """
        spec = ParsedSpec(raw_markdown=self.markdown)

        # Parse main sections
        spec.title, spec.spec_id, header_meta = self._parse_header()
        spec.status = header_meta.get('status', 'pending')
        spec.completed_tasks = header_meta.get('completed_tasks', 0)
        spec.total_tasks = header_meta.get('total_tasks', 0)
        spec.progress_pct = header_meta.get('progress_pct', 0.0)
        spec.estimated_hours = header_meta.get('estimated_hours')
        spec.complexity = header_meta.get('complexity')
        spec.description = header_meta.get('description')

        # Parse objectives
        spec.objectives = self._parse_objectives()

        # Parse phases
        spec.phases = self._parse_phases()

        return spec

    def _parse_header(self) -> tuple[str, str, Dict[str, Any]]:
        """Parse header section.

        Returns:
            Tuple of (title, spec_id, metadata_dict)
        """
        title = ""
        spec_id = ""
        metadata = {}

        for line in self.lines[:20]:  # Header should be in first 20 lines
            # Extract title from # heading
            if line.startswith('# '):
                title = line[2:].strip()

            # Extract spec ID
            elif '**Spec ID:**' in line:
                match = re.search(r'`([^`]+)`', line)
                if match:
                    spec_id = match.group(1)

            # Extract status and progress
            elif '**Status:**' in line:
                # Format: **Status:** pending (5/23 tasks, 22%)
                match = re.search(r'(\w+)\s+\((\d+)/(\d+)\s+tasks,\s+(\d+)%\)', line)
                if match:
                    metadata['status'] = match.group(1)
                    metadata['completed_tasks'] = int(match.group(2))
                    metadata['total_tasks'] = int(match.group(3))
                    metadata['progress_pct'] = float(match.group(4))

            # Extract estimated effort
            elif '**Estimated Effort:**' in line:
                match = re.search(r'(\d+(?:\.\d+)?)\s+hours', line)
                if match:
                    metadata['estimated_hours'] = float(match.group(1))

            # Extract complexity
            elif '**Complexity:**' in line:
                complexity = line.split('**Complexity:**')[1].strip()
                metadata['complexity'] = complexity

            # Extract description (paragraph after metadata)
            elif line and not line.startswith('#') and not line.startswith('**') and title:
                if 'description' not in metadata:
                    metadata['description'] = line.strip()

        return title, spec_id, metadata

    def _parse_objectives(self) -> List[str]:
        """Parse objectives section.

        Returns:
            List of objective strings
        """
        objectives = []
        in_objectives = False

        for line in self.lines:
            if line.strip() == '## Objectives':
                in_objectives = True
                continue

            if in_objectives:
                # Stop at next ## heading
                if line.startswith('## ') and line.strip() != '## Objectives':
                    break

                # Parse objective list items
                if line.strip().startswith('- '):
                    objectives.append(line.strip()[2:])

        return objectives

    def _parse_phases(self) -> List[ParsedPhase]:
        """Parse all phase sections.

        Returns:
            List of ParsedPhase objects
        """
        phases = []
        phase_indices = []

        # Find all phase headings (## level, but not Objectives)
        for i, line in enumerate(self.lines):
            if line.startswith('## ') and 'Objectives' not in line:
                phase_indices.append(i)

        # Parse each phase
        for i, start_idx in enumerate(phase_indices):
            end_idx = phase_indices[i + 1] if i + 1 < len(phase_indices) else len(self.lines)
            phase_lines = self.lines[start_idx:end_idx]
            phase = self._parse_phase('\n'.join(phase_lines))
            phases.append(phase)

        return phases

    def _parse_phase(self, phase_markdown: str) -> ParsedPhase:
        """Parse a single phase section.

        Args:
            phase_markdown: Markdown for this phase

        Returns:
            ParsedPhase object
        """
        phase = ParsedPhase(raw_markdown=phase_markdown)
        lines = phase_markdown.split('\n')

        # Parse phase header
        if lines and lines[0].startswith('## '):
            header = lines[0][3:].strip()
            # Format: "Phase Title (5/23 tasks, 22%)"
            match = re.match(r'(.+?)\s+\((\d+)/(\d+)\s+tasks,\s+(\d+)%\)', header)
            if match:
                phase.title = match.group(1)
                phase.completed_tasks = int(match.group(2))
                phase.total_tasks = int(match.group(3))
                phase.progress_pct = float(match.group(4))
            else:
                phase.title = header

        # Parse phase metadata
        for line in lines[1:10]:  # Metadata should be near top
            if '**Purpose:**' in line:
                phase.purpose = line.split('**Purpose:**')[1].strip()
            elif '**Risk Level:**' in line:
                phase.risk_level = line.split('**Risk Level:**')[1].strip()
            elif '**Estimated Hours:**' in line:
                match = re.search(r'(\d+(?:\.\d+)?)', line)
                if match:
                    phase.estimated_hours = float(match.group(1))
            elif '**Blocked by:**' in line:
                blockers = line.split('**Blocked by:**')[1].strip().split(', ')
                phase.blocked_by = [b.strip() for b in blockers]
            elif '**Depends on:**' in line:
                deps = line.split('**Depends on:**')[1].strip().split(', ')
                phase.depends_on = [d.strip() for d in deps]

        # Parse groups (### level headings)
        phase.groups = self._parse_groups(phase_markdown)

        return phase

    def _parse_groups(self, phase_markdown: str) -> List[ParsedGroup]:
        """Parse task groups within a phase.

        Args:
            phase_markdown: Markdown for the phase

        Returns:
            List of ParsedGroup objects
        """
        groups = []
        lines = phase_markdown.split('\n')
        group_indices = []

        # Find all group headings (### level)
        for i, line in enumerate(lines):
            if line.startswith('### '):
                group_indices.append(i)

        # Parse each group
        for i, start_idx in enumerate(group_indices):
            end_idx = group_indices[i + 1] if i + 1 < len(group_indices) else len(lines)
            group_lines = lines[start_idx:end_idx]
            group = self._parse_group('\n'.join(group_lines))
            groups.append(group)

        return groups

    def _parse_group(self, group_markdown: str) -> ParsedGroup:
        """Parse a single task group.

        Args:
            group_markdown: Markdown for this group

        Returns:
            ParsedGroup object
        """
        group = ParsedGroup(raw_markdown=group_markdown)
        lines = group_markdown.split('\n')

        # Parse group header
        if lines and lines[0].startswith('### '):
            header = lines[0][4:].strip()
            # Format: "Group Title (5/10 tasks)"
            match = re.match(r'(.+?)\s+\((\d+)/(\d+)\s+tasks\)', header)
            if match:
                group.title = match.group(1)
                group.completed_tasks = int(match.group(2))
                group.total_tasks = int(match.group(3))
            else:
                group.title = header

        # Parse group metadata
        for line in lines[1:5]:
            if '**Blocked by:**' in line:
                blockers = line.split('**Blocked by:**')[1].strip().split(', ')
                group.blocked_by = [b.strip() for b in blockers]

        # Parse tasks (#### level headings)
        group.tasks = self._parse_tasks(group_markdown)

        # Parse verifications (also #### level but with specific format)
        group.verifications = self._parse_verifications(group_markdown)

        return group

    def _parse_tasks(self, group_markdown: str) -> List[ParsedTask]:
        """Parse tasks within a group.

        Args:
            group_markdown: Markdown for the group

        Returns:
            List of ParsedTask objects
        """
        tasks = []
        lines = group_markdown.split('\n')
        task_indices = []

        # Find all task headings (####+ level)
        for i, line in enumerate(lines):
            # Match #### or ##### etc. with emoji status icons
            if re.match(r'^#{4,}\s+[â³ğŸ”„âœ…ğŸš«âŒâ“]', line):
                # Skip if this looks like a verification (has **Type:** field nearby)
                is_verification = False
                for check_line in lines[i:min(i+10, len(lines))]:
                    if '**Type:**' in check_line:
                        is_verification = True
                        break

                if not is_verification:
                    task_indices.append(i)

        # Parse each task
        for i, start_idx in enumerate(task_indices):
            end_idx = task_indices[i + 1] if i + 1 < len(task_indices) else len(lines)
            task_lines = lines[start_idx:end_idx]
            task = self._parse_task('\n'.join(task_lines))
            tasks.append(task)

        return tasks

    def _parse_task(self, task_markdown: str) -> ParsedTask:
        """Parse a single task.

        Args:
            task_markdown: Markdown for this task

        Returns:
            ParsedTask object
        """
        task = ParsedTask(raw_markdown=task_markdown)
        lines = task_markdown.split('\n')

        # Parse task header
        if lines and lines[0].startswith('#'):
            # Count heading level
            task.level = len(lines[0]) - len(lines[0].lstrip('#'))

            # Extract title (remove emoji and heading markers)
            header = lines[0].lstrip('#').strip()
            # Remove status emoji
            header = re.sub(r'^[â³ğŸ”„âœ…ğŸš«âŒâ“]\s*', '', header)
            task.title = header.strip()

        # Parse task metadata
        for line in lines[1:]:
            if '**File:**' in line:
                match = re.search(r'`([^`]+)`', line)
                if match:
                    task.file_path = match.group(1)

            elif '**Status:**' in line:
                status = line.split('**Status:**')[1].strip()
                task.status = status

            elif '**Estimated:**' in line:
                match = re.search(r'(\d+(?:\.\d+)?)\s+hours', line)
                if match:
                    task.estimated_hours = float(match.group(1))

            elif '**Changes:**' in line:
                task.changes = line.split('**Changes:**')[1].strip()

            elif '**Reasoning:**' in line:
                task.reasoning = line.split('**Reasoning:**')[1].strip()

            elif '**Details:**' in line:
                task.details = line.split('**Details:**')[1].strip()

            elif '**Depends on:**' in line:
                deps = line.split('**Depends on:**')[1].strip().split(', ')
                task.depends_on = [d.strip() for d in deps]

            elif '**Blocked by:**' in line:
                blockers = line.split('**Blocked by:**')[1].strip().split(', ')
                task.blocked_by = [b.strip() for b in blockers]

        return task

    def _parse_verifications(self, group_markdown: str) -> List[ParsedVerification]:
        """Parse verification steps within a group.

        Args:
            group_markdown: Markdown for the group

        Returns:
            List of ParsedVerification objects
        """
        verifications = []
        lines = group_markdown.split('\n')

        # Find verification headings (####+ with emoji and **Type:** nearby)
        for i, line in enumerate(lines):
            if re.match(r'^#{4,}\s+[â³ğŸ”„âœ…ğŸš«âŒâ“]', line):
                # Check if this is a verification (has **Type:** field)
                is_verification = False
                for check_line in lines[i:min(i+10, len(lines))]:
                    if '**Type:**' in check_line:
                        is_verification = True
                        break

                if is_verification:
                    # Find end of this verification
                    end_idx = len(lines)
                    for j in range(i + 1, len(lines)):
                        if lines[j].startswith('####'):
                            end_idx = j
                            break

                    verify_lines = lines[i:end_idx]
                    verify = self._parse_verification('\n'.join(verify_lines))
                    verifications.append(verify)

        return verifications

    def _parse_verification(self, verify_markdown: str) -> ParsedVerification:
        """Parse a single verification step.

        Args:
            verify_markdown: Markdown for this verification

        Returns:
            ParsedVerification object
        """
        verify = ParsedVerification(raw_markdown=verify_markdown)
        lines = verify_markdown.split('\n')

        # Parse verification header
        if lines and lines[0].startswith('####'):
            header = lines[0].lstrip('#').strip()
            # Remove status emoji
            header = re.sub(r'^[â³ğŸ”„âœ…ğŸš«âŒâ“]\s*', '', header)
            verify.title = header.strip()

        # Parse verification metadata
        in_command = False
        command_lines = []

        for i, line in enumerate(lines[1:]):
            if '**Status:**' in line:
                status = line.split('**Status:**')[1].strip()
                verify.status = status

            elif '**Type:**' in line:
                vtype = line.split('**Type:**')[1].strip()
                verify.verification_type = vtype

            elif '**Command:**' in line:
                in_command = True
                continue

            elif in_command:
                if line.strip() == '```bash':
                    continue
                elif line.strip() == '```':
                    in_command = False
                    verify.command = '\n'.join(command_lines)
                    command_lines = []
                else:
                    command_lines.append(line)

            elif '**Expected:**' in line:
                verify.expected = line.split('**Expected:**')[1].strip()

        return verify
