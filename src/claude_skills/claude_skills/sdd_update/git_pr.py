"""Git push and pull request integration for sdd-update workflows.

Provides utilities for automatic git push and PR creation after spec completion.
"""

from __future__ import annotations

import subprocess
import logging
import re
from pathlib import Path
from typing import Dict, Optional, Tuple, Any

from claude_skills.common.git_metadata import find_git_root
from claude_skills.common.git_config import is_git_enabled

logger = logging.getLogger(__name__)


def generate_pr_body(
    spec_data: Dict[str, Any],
    repo_root: Optional[Path] = None,
    base_branch: Optional[str] = None
) -> str:
    """Generate PR body template from spec metadata.

    Creates a structured PR description including:
    - Spec title and description
    - Completed tasks list
    - Phase completion summary
    - Commit history (queried from git)
    - Verification results

    Args:
        spec_data: JSON spec file data
        repo_root: Path to repository root (optional, for commit history)
        base_branch: Base branch name (optional, for commit history)

    Returns:
        Formatted PR body as markdown string
    """
    lines = []

    # Summary section
    lines.append("## Summary")
    lines.append("")

    title = spec_data.get('metadata', {}).get('title', 'Untitled Spec')
    lines.append(title)
    lines.append("")

    description = spec_data.get('metadata', {}).get('description', '')
    if description:
        lines.append(description)
        lines.append("")

    # Completed tasks section
    hierarchy = spec_data.get('hierarchy', {})
    completed_tasks = []

    for node_id, node in hierarchy.items():
        if node.get('type') == 'task' and node.get('status') == 'completed':
            task_title = node.get('title', node_id)
            completed_tasks.append(f"- ✅ {task_title}")

    if completed_tasks:
        lines.append("## Completed Tasks")
        lines.append("")
        lines.extend(completed_tasks)
        lines.append("")

    # Phases completed section
    phases = []
    for node_id, node in hierarchy.items():
        if node.get('type') == 'phase':
            phase_title = node.get('title', node_id)
            completed = node.get('completed_tasks', 0)
            total = node.get('total_tasks', 0)
            status = node.get('status', 'unknown')
            status_emoji = "✅" if status == "completed" else "⏸️"
            phases.append(f"- {status_emoji} **{phase_title}**: {completed}/{total} tasks")

    if phases:
        lines.append("## Phases Completed")
        lines.append("")
        lines.extend(phases)
        lines.append("")

    # Commits section (query from git if repo_root and base_branch provided)
    commits = []
    if repo_root and base_branch:
        try:
            result = subprocess.run(
                ["git", "log", f"{base_branch}...HEAD", "--format=%H|%s", "--reverse"],
                cwd=repo_root,
                capture_output=True,
                text=True,
                timeout=30,
                check=True
            )
            for line in result.stdout.strip().split('\n'):
                if not line:
                    continue
                parts = line.split('|', 1)
                if len(parts) >= 2:
                    commits.append({
                        'sha': parts[0],
                        'message': parts[1]
                    })
        except Exception as e:
            logger.warning(f"Failed to get commit history from git: {e}")

    if commits:
        lines.append("## Commits")
        lines.append("")
        for commit in commits:
            sha = commit.get('sha', 'unknown')[:8]
            message = commit.get('message', 'No message')
            lines.append(f"- {sha}: {message}")
        lines.append("")

    # Verification section
    verification_tasks = []
    for node_id, node in hierarchy.items():
        if node.get('type') == 'verify':
            verify_title = node.get('title', node_id)
            status = node.get('status', 'unknown')
            result = node.get('metadata', {}).get('verification_result', {}).get('status', status)
            result_emoji = "✅" if result in ['PASSED', 'completed'] else "❌" if result == 'FAILED' else "⏸️"
            verification_tasks.append(f"- {result_emoji} {verify_title}")

    if verification_tasks:
        lines.append("## Verification")
        lines.append("")
        lines.extend(verification_tasks)
        lines.append("")

    # Footer
    lines.append("---")
    lines.append("Generated by SDD Toolkit")

    return "\n".join(lines)


def push_branch(
    repo_root: Path,
    branch_name: str
) -> Tuple[bool, str]:
    """Push branch to remote repository.

    Args:
        repo_root: Path to repository root directory
        branch_name: Name of branch to push

    Returns:
        Tuple of (success: bool, error_message: str)
        - success: True if push succeeded, False otherwise
        - error_message: Error message if failed, empty string if successful
    """
    try:
        # Push branch with upstream tracking
        result = subprocess.run(
            ['git', 'push', '-u', 'origin', branch_name],
            cwd=repo_root,
            capture_output=True,
            text=True,
            check=False
        )

        if result.returncode != 0:
            error_msg = f"git push failed: {result.stderr}"
            logger.warning(error_msg)
            return False, error_msg

        logger.info(f"Successfully pushed branch: {branch_name}")
        return True, ""

    except Exception as e:
        error_msg = f"Git push workflow failed: {e}"
        logger.warning(error_msg)
        return False, error_msg


def check_gh_available() -> bool:
    """Check if GitHub CLI (gh) is installed and available.

    Returns:
        True if gh is available, False otherwise
    """
    try:
        result = subprocess.run(
            ['which', 'gh'],
            capture_output=True,
            text=True,
            check=False
        )
        return result.returncode == 0
    except Exception:
        return False


def create_pull_request(
    repo_root: Path,
    title: str,
    body: str,
    base_branch: str
) -> Tuple[bool, Optional[str], Optional[int], str]:
    """Create pull request via GitHub CLI.

    Args:
        repo_root: Path to repository root directory
        title: PR title
        body: PR body (markdown formatted)
        base_branch: Base branch to merge into (e.g., 'main', 'develop')

    Returns:
        Tuple of (success: bool, pr_url: Optional[str], pr_number: Optional[int], error_message: str)
        - success: True if PR created successfully, False otherwise
        - pr_url: URL of created PR if successful, None otherwise
        - pr_number: PR number if successful, None otherwise
        - error_message: Error message if failed, empty string if successful
    """
    # Check if gh is available
    if not check_gh_available():
        error_msg = "GitHub CLI (gh) not found. Install from: https://cli.github.com/"
        logger.warning(error_msg)
        return False, None, None, error_msg

    try:
        # Create PR via gh CLI
        result = subprocess.run(
            ['gh', 'pr', 'create',
             '--title', title,
             '--body', body,
             '--base', base_branch],
            cwd=repo_root,
            capture_output=True,
            text=True,
            check=False
        )

        if result.returncode != 0:
            error_msg = f"gh pr create failed: {result.stderr}"
            logger.warning(error_msg)
            return False, None, None, error_msg

        # Parse PR URL from output
        pr_url = result.stdout.strip()

        # Extract PR number from URL
        # Example URL: https://github.com/owner/repo/pull/123
        pr_number = None
        match = re.search(r'/pull/(\d+)', pr_url)
        if match:
            pr_number = int(match.group(1))

        logger.info(f"Successfully created PR #{pr_number}: {pr_url}")
        return True, pr_url, pr_number, ""

    except Exception as e:
        error_msg = f"PR creation workflow failed: {e}"
        logger.warning(error_msg)
        return False, None, None, error_msg


def check_pr_readiness(
    spec_data: Dict[str, Any],
    spec_path: Path
) -> Optional[Dict[str, Any]]:
    """Check if PR workflow should be triggered.

    This is the main entry point that orchestrates all PR checks:
    1. Check if git integration is enabled
    2. Find repository root
    3. Check if branch metadata exists
    4. Check if auto_push is enabled

    Args:
        spec_data: JSON spec file data
        spec_path: Path to spec file

    Returns:
        Dict with PR readiness info if PR workflow should be triggered:
        {
            "should_create_pr": True,
            "repo_root": Path to repository,
            "branch_name": Feature branch name,
            "base_branch": Base branch name
        }

        Returns None if PR workflow should not be triggered.
    """
    # Step 1: Find repository root
    repo_root = find_git_root(spec_path.parent)
    if repo_root is None:
        logger.debug("No git repository found, skipping PR workflow")
        return None

    # Step 2: Check if git integration is enabled
    if not is_git_enabled(repo_root):
        logger.debug("Git integration is disabled, skipping PR workflow")
        return None

    # Step 3: Check if branch metadata exists
    git_metadata = spec_data.get('metadata', {}).get('git', {})
    branch_name = git_metadata.get('branch_name')
    base_branch = git_metadata.get('base_branch')

    if not branch_name or not base_branch:
        logger.debug("Branch metadata not found, skipping PR workflow")
        return None

    # All checks passed - PR workflow should be triggered
    return {
        "should_create_pr": True,
        "repo_root": repo_root,
        "branch_name": branch_name,
        "base_branch": base_branch
    }
